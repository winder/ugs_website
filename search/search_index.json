{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"A free and full featured gcode platform used for interfacing with advanced CNC controllers like GRBL , TinyG , g2core and Smoothieware . Universal Gcode Sender is a self-contained Java application which includes all external dependencies and can be used on most computers running Windows, MacOSX or Linux. Features Cross platform, can run on Windows, MacOSX, Linux, and Raspberry Pi. 3D Gcode Visualizer with color coded line segments and real time tool position feedback. Duration estimates. Support for Gamepads and Joysticks Web pendant interface Possible to connect a Gamepad Tool for drawing and generate gcode Over 3000 lines of unit test code, and another 1000 lines of comments documenting the tests. Configuratble gcode optimization: Remove comments Truncate decimal precision to configurable amount Convert arcs (G2/G3) to line segments Remove whitespace Screenshots Fully modular GUI, reconfigure windows to suite your needs. Built in gcode editor with line highlighter. Customizable keybindings. Zoom to selection with command and drag. Right click in the visualizer to jog to a specific XY location. Sponsors Donations Universal Gcode Sender is free software developed and maintained in my free time for the hobby cnc community. If you would like to make a monetary donation, all proceeds will be used to try convincing my wife that it is worth my time. input[type=\"radio\"] { margin: 0 5px 0 15px; } #donatebox { text-align:center; width: 300px; } $1 $5 $10 $25 Custom amount","title":"Home"},{"location":"#features","text":"Cross platform, can run on Windows, MacOSX, Linux, and Raspberry Pi. 3D Gcode Visualizer with color coded line segments and real time tool position feedback. Duration estimates. Support for Gamepads and Joysticks Web pendant interface Possible to connect a Gamepad Tool for drawing and generate gcode Over 3000 lines of unit test code, and another 1000 lines of comments documenting the tests. Configuratble gcode optimization: Remove comments Truncate decimal precision to configurable amount Convert arcs (G2/G3) to line segments Remove whitespace","title":"Features"},{"location":"#screenshots","text":"Fully modular GUI, reconfigure windows to suite your needs. Built in gcode editor with line highlighter. Customizable keybindings. Zoom to selection with command and drag. Right click in the visualizer to jog to a specific XY location.","title":"Screenshots"},{"location":"#sponsors","text":"","title":"Sponsors"},{"location":"#donations","text":"Universal Gcode Sender is free software developed and maintained in my free time for the hobby cnc community. If you would like to make a monetary donation, all proceeds will be used to try convincing my wife that it is worth my time. input[type=\"radio\"] { margin: 0 5px 0 15px; } #donatebox { text-align:center; width: 300px; } $1 $5 $10 $25 Custom amount","title":"Donations"},{"location":"contributing/","text":"Contributing If you are interested in contributing to make UGS even more awesome, there are many places you can pitch in. Browse through the already reported issues or check out the discussion forum . You might know how to code, have ideas on how to improve the documentation or want to translate the software to your language. Code Pull requests are welcome! Is there a feature you would like to see, or a bug thats been bothering you? Feel free to dig in. Not sure where to start? Ask on github, use an existing ticket or create a new one. If you're planning to make a lot of changes please create an issue to discuss implementation details. A lot of effort has gone into the current design so we want to make sure everything will to work together. Checkout the Developing wiki page for more details Documentation If you find any errors in the documentation or if there are missing pages, you are welcome to contribute! Translations We are currently using POEditor to manage localization. If you would like to help please consider signing up to contribute through this service. To join the project sign up here: https://poeditor.com/join/project/2J2hB5I41Z Adding a new language You can add a new language from POEditor and start translating. If you want to stop here, create a ticket on GitHub and someone will update the project. To finish the job completely you'll need to know how to use git . Create an empty property file for your language in ugs-core/src/resources . Open src/com/willwinder/universalgcodesender/i18n/AvailableLanguages.java Add your new translation to the availableLanguages object. Update the file in update_languages.py with a mapping between the POEditor key and your new file. Run update_languages.py , see README in scripts directory for configuration detail. Only commit the new file even if others were updated. Create a GitHub pull request . Future language syncs will be done periodically with the update_languages.py script.","title":"Contributing"},{"location":"contributing/#contributing","text":"If you are interested in contributing to make UGS even more awesome, there are many places you can pitch in. Browse through the already reported issues or check out the discussion forum . You might know how to code, have ideas on how to improve the documentation or want to translate the software to your language.","title":"Contributing"},{"location":"contributing/#code","text":"Pull requests are welcome! Is there a feature you would like to see, or a bug thats been bothering you? Feel free to dig in. Not sure where to start? Ask on github, use an existing ticket or create a new one. If you're planning to make a lot of changes please create an issue to discuss implementation details. A lot of effort has gone into the current design so we want to make sure everything will to work together. Checkout the Developing wiki page for more details","title":"Code"},{"location":"contributing/#documentation","text":"If you find any errors in the documentation or if there are missing pages, you are welcome to contribute!","title":"Documentation"},{"location":"contributing/#translations","text":"We are currently using POEditor to manage localization. If you would like to help please consider signing up to contribute through this service. To join the project sign up here: https://poeditor.com/join/project/2J2hB5I41Z","title":"Translations"},{"location":"contributing/#adding-a-new-language","text":"You can add a new language from POEditor and start translating. If you want to stop here, create a ticket on GitHub and someone will update the project. To finish the job completely you'll need to know how to use git . Create an empty property file for your language in ugs-core/src/resources . Open src/com/willwinder/universalgcodesender/i18n/AvailableLanguages.java Add your new translation to the availableLanguages object. Update the file in update_languages.py with a mapping between the POEditor key and your new file. Run update_languages.py , see README in scripts directory for configuration detail. Only commit the new file even if others were updated. Create a GitHub pull request . Future language syncs will be done periodically with the update_languages.py script.","title":"Adding a new language"},{"location":"download/","text":"Download This is the latest release of UGS. For source code, nightly builds or older releases please visit github . UGS Platform The next generation platform-based interface. Version 2.1.6 Description Windows 64-bit Windows 64-bit version with bundled Java MacOSX (Intel) MacOSX version with bundled Java MacOSX (Silicon) MacOSX ARM64 version (for Apple Silicon M1/M2) with bundled Java Linux Linux version with bundled Java Linux ARM Linux ARM version with bundled Java. Can be used with Raspberry Pi OS 32-bit Linux ARM64 Linux ARM64 version with bundled Java. Can be used with Raspberry Pi OS 64-bit All platforms A generic package without Java which needs to be installed separately UGS Classic The classic UGS interface with slightly less features but with the same robust backend as the Platform edition. Download Description All platforms A generic package without Java which needs to be installed separately","title":"Download"},{"location":"download/#download","text":"This is the latest release of UGS. For source code, nightly builds or older releases please visit github .","title":"Download"},{"location":"download/#ugs-platform","text":"The next generation platform-based interface. Version 2.1.6 Description Windows 64-bit Windows 64-bit version with bundled Java MacOSX (Intel) MacOSX version with bundled Java MacOSX (Silicon) MacOSX ARM64 version (for Apple Silicon M1/M2) with bundled Java Linux Linux version with bundled Java Linux ARM Linux ARM version with bundled Java. Can be used with Raspberry Pi OS 32-bit Linux ARM64 Linux ARM64 version with bundled Java. Can be used with Raspberry Pi OS 64-bit All platforms A generic package without Java which needs to be installed separately","title":"UGS Platform"},{"location":"download/#ugs-classic","text":"The classic UGS interface with slightly less features but with the same robust backend as the Platform edition. Download Description All platforms A generic package without Java which needs to be installed separately","title":"UGS Classic"},{"location":"installing/","text":"How to install To install Universal G-Code Sender, download the correct package for your operating system, unpack and run. See the videos below for detailed instructions. Windows MacOSX Linux","title":"Installing"},{"location":"installing/#how-to-install","text":"To install Universal G-Code Sender, download the correct package for your operating system, unpack and run. See the videos below for detailed instructions.","title":"How to install"},{"location":"installing/#windows","text":"","title":"Windows"},{"location":"installing/#macosx","text":"","title":"MacOSX"},{"location":"installing/#linux","text":"","title":"Linux"},{"location":"usage/","text":"Usage Check out our wiki for instructions on how to use Universal Gcode Sender Connecting to the controller Configuration Usage FAQ and Troubleshooting","title":"Usage"},{"location":"usage/#usage","text":"Check out our wiki for instructions on how to use Universal Gcode Sender Connecting to the controller Configuration Usage FAQ and Troubleshooting","title":"Usage"},{"location":"dev/backend_development/","text":"Backend architecture Similar to the front-end there are more layers on the backend to help with supporting differences between different gcode controllers and the different ways to communicate with these controllers. Because UGS depends on serial events from CNC devices, the communication between layers is also event driven. This is implemented using a series of Listener classes which pass messages from the lower levels to the upper levels whenever data is detected on the serial port (USB). Controller A controller is primarily responsible for implementing controller-specific features. Different features can be things like what happens when a Perform Homing command is requested, or how to issue status requests and parse their results. GRBL and TinyG are both supported, they share a lot of code with the AbstractController.java abstract class. Internally the AbstractController class implements several important things. It manages the stream lifecycle, keeping track of which commands have been sent, which have been completed and in some cases which are queued for sending. The controller also figures out when the stream has finished. Finally the AbstractController implements the SerialCommunicatorListener , which how its able to detect all of this state information (and allows commands to be sent to the CNC controller). The controller provides a ControllerListener interface which is used to provide real time status. Finally, the AbstractController defines a number of abstract methods which can be used by device specific controllers as needed to hook into important lifecycle events: abstract protected void closeCommBeforeEvent(); abstract protected void closeCommAfterEvent(); protected void openCommAfterEvent() throws Exception {} abstract protected void cancelSendBeforeEvent(); abstract protected void cancelSendAfterEvent(); abstract protected void pauseStreamingEvent() throws Exception; abstract protected void resumeStreamingEvent() throws Exception; abstract protected void isReadyToSendCommandsEvent() throws Exception; abstract protected void statusUpdatesEnabledValueChanged(boolean enabled); abstract protected void statusUpdatesRateValueChanged(int rate); // This one is special, because it is responsible for parsing device // responses, such as a command complete, status string, or parsing a // status event. In the case of a command complete, it must call // `commandComplete` to push the stream lifecycle along. abstract protected void rawResponseHandler(String response); Here is the public interface which controlles conform to: public interface IController { /* Observable */ public void addListener(ControllerListener cl); /* Actions */ public void performHomingCycle() throws Exception; public void returnToHome() throws Exception; public void resetCoordinatesToZero() throws Exception; public void resetCoordinateToZero(final char coord) throws Exception; public void killAlarmLock() throws Exception; public void toggleCheckMode() throws Exception; public void viewParserState() throws Exception; public void issueSoftReset() throws Exception; /* Behavior */ public void setSingleStepMode(boolean enabled); public boolean getSingleStepMode(); public void setStatusUpdatesEnabled(boolean enabled); public boolean getStatusUpdatesEnabled(); public void setStatusUpdateRate(int rate); public int getStatusUpdateRate(); public GcodeCommandCreator getCommandCreator(); public long getJobLengthEstimate(File gcodeFile); /* Serial */ public Boolean openCommPort(String port, int portRate) throws Exception; public Boolean closeCommPort() throws Exception; public Boolean isCommOpen(); /* Stream information */ public Boolean isReadyToStreamFile() throws Exception; public Boolean isStreamingFile(); public long getSendDuration(); public int rowsInSend(); public int rowsSent(); public int rowsRemaining(); /* Stream control */ public void beginStreaming() throws Exception; public void pauseStreaming() throws Exception; public void resumeStreaming() throws Exception; public void cancelSend(); /* Stream content */ public GcodeCommand createCommand(String gcode) throws Exception; public void sendCommandImmediately(GcodeCommand cmd) throws Exception; public void queueCommand(GcodeCommand cmd) throws Exception; public void queueStream(GcodeStreamReader r); public void queueRawStream(Reader r); } Communicator A communicator handles all levels of sending data to the device. Raw responses are returned to any listeners via the SerialCommunicatorListener . The AbstractCommunicator implements several listener utilities which are used by implementing classes. The BufferedCommunicator abstract class handles the process of buffering multiple commands at once in order to keep a constant stream of commands available to the CNC device. It does this in the streamCommands method by maintaining a list of active commands, and the current size of those commands. A method named processedCommand must be implemented in a subclass to determine whether a raw response indicates a command has completed. This notifies the BufferedCommunicator that it should attempt to send more commands. GrblCommunicator and TinyGCommunicator are two concrete implementations of the BufferedCommunicator . Connection This is a very thin layer which provides a way to write and receive data: abstract public boolean openPort(String name, int baud) throws Exception; abstract public void closePort() throws Exception; abstract public boolean isOpen(); abstract public void sendByteImmediately(byte b) throws Exception; abstract public void sendStringToComm(String command) throws Exception; Streaming strategy UGS attempts to use a fixed amount of memory when streaming a file. In this way it can send gcode files of any size. Files are preprocessed at the BackendAPI level using the GcodeStreamWriter class. This will serialize all the required metadata into a file. Later on that file can be opened with the GcodeStreamReader class, the Controller and Communicator classes use this. Using the reader, the Communicator class can pull out commands one at a time and send them to the Connection .","title":"Backend architecture"},{"location":"dev/backend_development/#backend-architecture","text":"Similar to the front-end there are more layers on the backend to help with supporting differences between different gcode controllers and the different ways to communicate with these controllers. Because UGS depends on serial events from CNC devices, the communication between layers is also event driven. This is implemented using a series of Listener classes which pass messages from the lower levels to the upper levels whenever data is detected on the serial port (USB).","title":"Backend architecture"},{"location":"dev/backend_development/#controller","text":"A controller is primarily responsible for implementing controller-specific features. Different features can be things like what happens when a Perform Homing command is requested, or how to issue status requests and parse their results. GRBL and TinyG are both supported, they share a lot of code with the AbstractController.java abstract class. Internally the AbstractController class implements several important things. It manages the stream lifecycle, keeping track of which commands have been sent, which have been completed and in some cases which are queued for sending. The controller also figures out when the stream has finished. Finally the AbstractController implements the SerialCommunicatorListener , which how its able to detect all of this state information (and allows commands to be sent to the CNC controller). The controller provides a ControllerListener interface which is used to provide real time status. Finally, the AbstractController defines a number of abstract methods which can be used by device specific controllers as needed to hook into important lifecycle events: abstract protected void closeCommBeforeEvent(); abstract protected void closeCommAfterEvent(); protected void openCommAfterEvent() throws Exception {} abstract protected void cancelSendBeforeEvent(); abstract protected void cancelSendAfterEvent(); abstract protected void pauseStreamingEvent() throws Exception; abstract protected void resumeStreamingEvent() throws Exception; abstract protected void isReadyToSendCommandsEvent() throws Exception; abstract protected void statusUpdatesEnabledValueChanged(boolean enabled); abstract protected void statusUpdatesRateValueChanged(int rate); // This one is special, because it is responsible for parsing device // responses, such as a command complete, status string, or parsing a // status event. In the case of a command complete, it must call // `commandComplete` to push the stream lifecycle along. abstract protected void rawResponseHandler(String response); Here is the public interface which controlles conform to: public interface IController { /* Observable */ public void addListener(ControllerListener cl); /* Actions */ public void performHomingCycle() throws Exception; public void returnToHome() throws Exception; public void resetCoordinatesToZero() throws Exception; public void resetCoordinateToZero(final char coord) throws Exception; public void killAlarmLock() throws Exception; public void toggleCheckMode() throws Exception; public void viewParserState() throws Exception; public void issueSoftReset() throws Exception; /* Behavior */ public void setSingleStepMode(boolean enabled); public boolean getSingleStepMode(); public void setStatusUpdatesEnabled(boolean enabled); public boolean getStatusUpdatesEnabled(); public void setStatusUpdateRate(int rate); public int getStatusUpdateRate(); public GcodeCommandCreator getCommandCreator(); public long getJobLengthEstimate(File gcodeFile); /* Serial */ public Boolean openCommPort(String port, int portRate) throws Exception; public Boolean closeCommPort() throws Exception; public Boolean isCommOpen(); /* Stream information */ public Boolean isReadyToStreamFile() throws Exception; public Boolean isStreamingFile(); public long getSendDuration(); public int rowsInSend(); public int rowsSent(); public int rowsRemaining(); /* Stream control */ public void beginStreaming() throws Exception; public void pauseStreaming() throws Exception; public void resumeStreaming() throws Exception; public void cancelSend(); /* Stream content */ public GcodeCommand createCommand(String gcode) throws Exception; public void sendCommandImmediately(GcodeCommand cmd) throws Exception; public void queueCommand(GcodeCommand cmd) throws Exception; public void queueStream(GcodeStreamReader r); public void queueRawStream(Reader r); }","title":"Controller"},{"location":"dev/backend_development/#communicator","text":"A communicator handles all levels of sending data to the device. Raw responses are returned to any listeners via the SerialCommunicatorListener . The AbstractCommunicator implements several listener utilities which are used by implementing classes. The BufferedCommunicator abstract class handles the process of buffering multiple commands at once in order to keep a constant stream of commands available to the CNC device. It does this in the streamCommands method by maintaining a list of active commands, and the current size of those commands. A method named processedCommand must be implemented in a subclass to determine whether a raw response indicates a command has completed. This notifies the BufferedCommunicator that it should attempt to send more commands. GrblCommunicator and TinyGCommunicator are two concrete implementations of the BufferedCommunicator .","title":"Communicator"},{"location":"dev/backend_development/#connection","text":"This is a very thin layer which provides a way to write and receive data: abstract public boolean openPort(String name, int baud) throws Exception; abstract public void closePort() throws Exception; abstract public boolean isOpen(); abstract public void sendByteImmediately(byte b) throws Exception; abstract public void sendStringToComm(String command) throws Exception;","title":"Connection"},{"location":"dev/backend_development/#streaming-strategy","text":"UGS attempts to use a fixed amount of memory when streaming a file. In this way it can send gcode files of any size. Files are preprocessed at the BackendAPI level using the GcodeStreamWriter class. This will serialize all the required metadata into a file. Later on that file can be opened with the GcodeStreamReader class, the Controller and Communicator classes use this. Using the reader, the Communicator class can pull out commands one at a time and send them to the Connection .","title":"Streaming strategy"},{"location":"dev/frontend_development/","text":"Front-end Architecture UGS uses a Model-View-Presenter architecture. What this means is that at a high level there are three layers which each serve different purposes. A Model for all backend logic, a View displayed to the user and a Presenter which serves as a buffer between the model and one or more views. Model The model contains all backend logic. Things like opening a connection, listing serial ports, streaming a file, and handling firmware specific nuances. All of this is hidden from the front end as much as possible. View The view only has access to the presenter. It is responsible for all user interaction and feedback. The main logic in here should be things like enabling or disabling components based on the current state of the model. Classic GUI The Classic GUI is built using NetBeans. There are a number of custom Swing components, and they are all initialized with the NetBeans GUI builder. The vast majority of the Classic GUI code is contained in MainWindow.java . There isn't a lot to expand on here, this front end has grown organically over the years and is fairly rigid. The Visualizer component is a standalone JOGL window which is updated using events from the backend (it was a model for many of the improvements in the current applications architecture). UGS Platform The UGS Platform build is also built using NetBeans. It is a built ontop of the NetBeans Platform which provides it a robust set of tools like flexible windows, a plugin framework, and a suite of tools for module communications. At the core of this is a module named UGSLib which is a simple wrapper to the standard UGS JAR file. There is a suite of modules named UGSCore which provides many of the standard UI elements seen in the Classic GUI , in addition there are other modules that provide new functionality. Extending the GUI is now a matter of creating a new plugin, for details on how to do this see the Plugin Tutorial . Presenter The presenter serves as an API for the model. All the heavy lifting needed for the GUI should happen here. For example the controller model object knows how to stream a processed file, but it doesn't know how to process the file. So the presenter will pass data to the gcode processor and generate a processed object which can be passed to the controller. Similarly, all notifications from the model are reinterpreted for the view with a simpler message strategy. In this way, all updates to the backend code can be leveraged by all front ends which utilize UGS. BackendAPI In UGS interfaces named BackendAPI and BackendAPIReadOnly provide the presenter layer. The read only methods are split off into a sub-interface in case a developer wants to be sure they don't change any state. For instance a widget that displays the current machine location probably has no need for pausing a stream. These APIs are used by all front ends ( Classic GUI , PendantUI and UGS Platform ).","title":"Front-end Architecture"},{"location":"dev/frontend_development/#front-end-architecture","text":"UGS uses a Model-View-Presenter architecture. What this means is that at a high level there are three layers which each serve different purposes. A Model for all backend logic, a View displayed to the user and a Presenter which serves as a buffer between the model and one or more views.","title":"Front-end Architecture"},{"location":"dev/frontend_development/#model","text":"The model contains all backend logic. Things like opening a connection, listing serial ports, streaming a file, and handling firmware specific nuances. All of this is hidden from the front end as much as possible.","title":"Model"},{"location":"dev/frontend_development/#view","text":"The view only has access to the presenter. It is responsible for all user interaction and feedback. The main logic in here should be things like enabling or disabling components based on the current state of the model.","title":"View"},{"location":"dev/frontend_development/#classic-gui","text":"The Classic GUI is built using NetBeans. There are a number of custom Swing components, and they are all initialized with the NetBeans GUI builder. The vast majority of the Classic GUI code is contained in MainWindow.java . There isn't a lot to expand on here, this front end has grown organically over the years and is fairly rigid. The Visualizer component is a standalone JOGL window which is updated using events from the backend (it was a model for many of the improvements in the current applications architecture).","title":"Classic GUI"},{"location":"dev/frontend_development/#ugs-platform","text":"The UGS Platform build is also built using NetBeans. It is a built ontop of the NetBeans Platform which provides it a robust set of tools like flexible windows, a plugin framework, and a suite of tools for module communications. At the core of this is a module named UGSLib which is a simple wrapper to the standard UGS JAR file. There is a suite of modules named UGSCore which provides many of the standard UI elements seen in the Classic GUI , in addition there are other modules that provide new functionality. Extending the GUI is now a matter of creating a new plugin, for details on how to do this see the Plugin Tutorial .","title":"UGS Platform"},{"location":"dev/frontend_development/#presenter","text":"The presenter serves as an API for the model. All the heavy lifting needed for the GUI should happen here. For example the controller model object knows how to stream a processed file, but it doesn't know how to process the file. So the presenter will pass data to the gcode processor and generate a processed object which can be passed to the controller. Similarly, all notifications from the model are reinterpreted for the view with a simpler message strategy. In this way, all updates to the backend code can be leveraged by all front ends which utilize UGS.","title":"Presenter"},{"location":"dev/frontend_development/#backendapi","text":"In UGS interfaces named BackendAPI and BackendAPIReadOnly provide the presenter layer. The read only methods are split off into a sub-interface in case a developer wants to be sure they don't change any state. For instance a widget that displays the current machine location probably has no need for pausing a stream. These APIs are used by all front ends ( Classic GUI , PendantUI and UGS Platform ).","title":"BackendAPI"},{"location":"dev/gcode_processor/","text":"Gcode Processor Development The UGS core library has a flexible gcode processor plugin system. It is designed as a processing pipeline to convert one line of code at a time by passing it through multiple Command Processor plugins. Some advanced features in UGS, like the Auto Leveler, take advantage of this feature to inject a special processor module into the gcode processing pipeline. Other processors are simpler, such as the M30Processor which simply removes unwanted M30 commands, or the CommandLengthProcessor which causes an error if the final processed line has too much data for your controller. This process is configured using a JSON file which holds processor configuration, order in which processors should appear in the pipeline, and whether or not they are enabled. All of this is configurable in UGS and UGP in a Gcode Processor Configuration menu. Anatomy of a CommandProcessor The processor interface is simple. One command goes in along with the current state and a list of output commands come out. A CommandProcessor might discover invalid input, in which case a GcodeParserException can be thrown for the GcodeParser to handle. public interface CommandProcessor { /** * Given a command and the current state of a program returns a replacement * list of commands. * @param command Input gcode. * @param state State of the gcode parser when the command will run. * @return One or more gcode commands to replace the original command with. */ public List<String> processCommand(String command, GcodeState state) throws GcodeParserException; /** * Returns information about the current command and its configuration. * @return */ public String getHelp(); } Simple Example The CommandLengthProcessor is one of the simplest examples of a CommandProcessor. One thing of interest is that it accepts a length parameter during configuration. By adding a CommandLengthProcessor to the GcodeParser, you can ensure the maximum length of commands. public class CommandLengthProcessor implements CommandProcessor { final private int length; public CommandLengthProcessor(int length) { this.length = length; } @Override public String getHelp() { // Global localization helpers are used for the help message. return Localization.getString(\"sender.help.command.length\") + \"\\n\" + Localization.getString(\"sender.command.length\") + \": \" + length; } @Override public List<String> processCommand(String command, GcodeState state) throws GcodeParserException { if (command.length() > length) throw new GcodeParserException(\"Command '\" + command + \"' is longer than \" + length + \" characters.\"); return Collections.singletonList(command); } } More Complex Examples The following examples can be found in GitHub, they wont have the full code included. DecimalProcessor This is only slightly more complicated than the CommandLengthProcessor. It adds in some config validation by throwing a RuntimeException in the constructor, which is handled by code which configures the GcodeParser. The processCommand method is then able to truncate any decimals using simple string manipulation. FeedOverrideProcessor Like the DecimalProcessor , the FeedOverrideProcessor is able to modifie any F-Commands with simple string manipulation. LineSplitter The LineSplitter CommandProcessor will actually modify commands by parsing the gcode and rewriting it. There are several utilities used here to help: GcodeParser.processCommand - Converts the command string into something easier to work with. GcodePreprocessorUtils.extractMotion - Helper to extract all words associated to movement commands, the remainder should still be sent but may not be sent in the context of the rewritten command. The remaining logic checks the length of any G0 or G1 commands and converts them, or returns the original command unmodified. Tutorial: Creating a New CommandProcessor Creating a fully integrated and configurable CommandProcessor is simple, but does touch a number of different files. This tutorial will go over those pieces in the context of creating a processor named M3Dweller . Goal Create a processor which inserts a Dwell command (short delay) whenever the spindle is enabled. This allows any potentially slow setups such as VFD's to come up to speed. It should be configurable via the Gcode Processor Configuration menu. Creating the processor First you'll notice that the constructor initializes the command which should be added after our spindle start M3 command. The locale is set to make sure comma is not used as a decimal separator: private final String dwellCommand; public M3Dweller(double dwellDuration) { this.dwellCommand = String.format(Locale.ROOT, \"G4P%.2f\", dwellDuration); } The help method simply adds some comments for the settings GUI: @Override public String getHelp() { return \"Add a delay after enabling the spindle with \\\"M3\\\" commands. \\\"M3\\\" must be the only command on the line.\"; } Everything is then pulled together in the processCommand method to return an extra dwell command when M3 is detected: // Contains an M3 not followed by another digit (i.e. M30) Pattern m3Pattern = Pattern.compile(\".*[mM]3(?!\\\\d)(\\\\D.*)?\"); @Override public List<String> processCommand(String command, GcodeState state) throws GcodeParserException { if (m3Pattern.matcher(command).matches()) { return Arrays.asList(command, dwellCommand); } return Collections.singletonList(command); } All at once now: public class M3Dweller implements CommandProcessor { private final String dwellCommand; // Contains an M3 not followed by another digit (i.e. M30) Pattern m3Pattern = Pattern.compile(\".*[mM]3(?!\\\\d)(\\\\D.*)?\"); public M3Dweller(double dwellDuration) { this.dwellCommand = String.format(Locale.ROOT, \"G4P%.2f\", dwellDuration); } @Override public List<String> processCommand(String command, GcodeState state) throws GcodeParserException { String noComments = GcodePreprocessorUtils.removeComment(command); if (m3Pattern.matcher(noComments).matches()) { return Arrays.asList(command, dwellCommand); } return Collections.singletonList(command); } @Override public String getHelp() { return \"Add a delay after enabling the spindle with \\\"M3\\\" commands. \\\"M3\\\" must be the only command on the line.\"; } } Hooking up the JSON The json files are stored in ugs-core/src/resources/firmware_config , each of these will be updated to include our new processor. Notice that we have an argument named duration, and that it is disabled by default: \"name\": \"M3Dweller\", \"enabled\": false, \"optional\": true, \"args\": { \"duration\": 2.5 } },{ We also increment the version string, which will prompt users that there is a new configuration file available and they may need to revisit their settings: - \"Version\": 3, + \"Version\": 4, JSON Loader The last step is to update the CommandProcessorLoader to include logic that creates the new M3Dweller when needed. I used one of the other processors as an example and made sure to make a corresponding entry for the M3Dweller in each of the corresponding code and comment locations: case \"M3Dweller\": double duration = pc.args.get(\"duration\").getAsDouble(); p = new M3Dweller(duration); break; There is also a test which should be updated to make sure everything is working: + args = new JsonObject(); + args.addProperty(\"duration\", 2.5); + object = new JsonObject(); + object.addProperty(\"name\", \"M3Dweller\"); + object.add(\"args\", args); + array.add(object); + String jsonConfig = array.toString(); List<CommandProcessor> processors = CommandProcessorLoader.initializeWithProcessors(jsonConfig); - assertEquals(8, processors.size()); + assertEquals(9, processors.size()); assertEquals(ArcExpander.class, processors.get(0).getClass()); assertEquals(CommentProcessor.class, processors.get(1).getClass()); assertEquals(DecimalProcessor.class, processors.get(2).getClass()); assertEquals(FeedOverrideProcessor.class, processors.get(3).getClass()); assertEquals(M30Processor.class, processors.get(4).getClass()); assertEquals(PatternRemover.class, processors.get(5).getClass()); assertEquals(CommandLengthProcessor.class, processors.get(6).getClass()); assertEquals(WhitespaceProcessor.class, processors.get(7).getClass()); + assertEquals(M3Dweller.class, processors.get(8).getClass()); Testing The command processors lend themselves to thorough testing, so we create a new M3DwellerTest.java file in the associated test package and write some tests: @Test public void testReplaces() throws Exception { M3Dweller dweller = new M3Dweller(2.5); String command; command = \"M3\"; Assertions.assertThat(dweller.processCommand(command, null)).containsExactly(command,\"G4P2.50\"); command = \"m3\"; Assertions.assertThat(dweller.processCommand(command, null)).containsExactly(command,\"G4P2.50\"); command = \"M3 S1000\"; Assertions.assertThat(dweller.processCommand(command, null)).containsExactly(command,\"G4P2.50\"); command = \"m3 S1000\"; Assertions.assertThat(dweller.processCommand(command, null)).containsExactly(command,\"G4P2.50\"); command = \"(this is ignored) M3 S1000\"; Assertions.assertThat(dweller.processCommand(command, null)).containsExactly(command,\"G4P2.50\"); } @Test public void testNoOp() throws Exception { M3Dweller dweller = new M3Dweller(2.5); String command; command = \"anything else\"; Assertions.assertThat(dweller.processCommand(command, null)).containsExactly(command); command = \"M30\"; Assertions.assertThat(dweller.processCommand(command, null)).containsExactly(command); command = \"G0 X0 Y0 (definitely not ready to start the spindle with an M3 yet)\"; Assertions.assertThat(dweller.processCommand(command, null)).containsExactly(command); } Localizing In addition to the help message which may use the global Localization helper, the settings menu will attempt to find something with the same name as in the JSON file. So we add an entry to ./ugs-core/src/resources/MessagesBundle_en_US.properties , which will later be pulled into a separate localization service to be localized in other languages. WhitespaceProcessor = Whitespace Remover +M3Dweller = Spindle start delay controller.exception.smoothie.booting = Smoothie has not finished booting. Conclusion We have now fully integrated our M3Dweller processor into the UGS framework and users of UGS and UGP can both make use of it. The raw commit for this feature is found on github here .","title":"Gcode Processor Development"},{"location":"dev/gcode_processor/#gcode-processor-development","text":"The UGS core library has a flexible gcode processor plugin system. It is designed as a processing pipeline to convert one line of code at a time by passing it through multiple Command Processor plugins. Some advanced features in UGS, like the Auto Leveler, take advantage of this feature to inject a special processor module into the gcode processing pipeline. Other processors are simpler, such as the M30Processor which simply removes unwanted M30 commands, or the CommandLengthProcessor which causes an error if the final processed line has too much data for your controller. This process is configured using a JSON file which holds processor configuration, order in which processors should appear in the pipeline, and whether or not they are enabled. All of this is configurable in UGS and UGP in a Gcode Processor Configuration menu.","title":"Gcode Processor Development"},{"location":"dev/gcode_processor/#anatomy-of-a-commandprocessor","text":"The processor interface is simple. One command goes in along with the current state and a list of output commands come out. A CommandProcessor might discover invalid input, in which case a GcodeParserException can be thrown for the GcodeParser to handle. public interface CommandProcessor { /** * Given a command and the current state of a program returns a replacement * list of commands. * @param command Input gcode. * @param state State of the gcode parser when the command will run. * @return One or more gcode commands to replace the original command with. */ public List<String> processCommand(String command, GcodeState state) throws GcodeParserException; /** * Returns information about the current command and its configuration. * @return */ public String getHelp(); }","title":"Anatomy of a CommandProcessor"},{"location":"dev/gcode_processor/#simple-example","text":"The CommandLengthProcessor is one of the simplest examples of a CommandProcessor. One thing of interest is that it accepts a length parameter during configuration. By adding a CommandLengthProcessor to the GcodeParser, you can ensure the maximum length of commands. public class CommandLengthProcessor implements CommandProcessor { final private int length; public CommandLengthProcessor(int length) { this.length = length; } @Override public String getHelp() { // Global localization helpers are used for the help message. return Localization.getString(\"sender.help.command.length\") + \"\\n\" + Localization.getString(\"sender.command.length\") + \": \" + length; } @Override public List<String> processCommand(String command, GcodeState state) throws GcodeParserException { if (command.length() > length) throw new GcodeParserException(\"Command '\" + command + \"' is longer than \" + length + \" characters.\"); return Collections.singletonList(command); } }","title":"Simple Example"},{"location":"dev/gcode_processor/#more-complex-examples","text":"The following examples can be found in GitHub, they wont have the full code included.","title":"More Complex Examples"},{"location":"dev/gcode_processor/#decimalprocessor","text":"This is only slightly more complicated than the CommandLengthProcessor. It adds in some config validation by throwing a RuntimeException in the constructor, which is handled by code which configures the GcodeParser. The processCommand method is then able to truncate any decimals using simple string manipulation.","title":"DecimalProcessor"},{"location":"dev/gcode_processor/#feedoverrideprocessor","text":"Like the DecimalProcessor , the FeedOverrideProcessor is able to modifie any F-Commands with simple string manipulation.","title":"FeedOverrideProcessor"},{"location":"dev/gcode_processor/#linesplitter","text":"The LineSplitter CommandProcessor will actually modify commands by parsing the gcode and rewriting it. There are several utilities used here to help: GcodeParser.processCommand - Converts the command string into something easier to work with. GcodePreprocessorUtils.extractMotion - Helper to extract all words associated to movement commands, the remainder should still be sent but may not be sent in the context of the rewritten command. The remaining logic checks the length of any G0 or G1 commands and converts them, or returns the original command unmodified.","title":"LineSplitter"},{"location":"dev/gcode_processor/#tutorial-creating-a-new-commandprocessor","text":"Creating a fully integrated and configurable CommandProcessor is simple, but does touch a number of different files. This tutorial will go over those pieces in the context of creating a processor named M3Dweller .","title":"Tutorial: Creating a New CommandProcessor"},{"location":"dev/gcode_processor/#goal","text":"Create a processor which inserts a Dwell command (short delay) whenever the spindle is enabled. This allows any potentially slow setups such as VFD's to come up to speed. It should be configurable via the Gcode Processor Configuration menu.","title":"Goal"},{"location":"dev/gcode_processor/#creating-the-processor","text":"First you'll notice that the constructor initializes the command which should be added after our spindle start M3 command. The locale is set to make sure comma is not used as a decimal separator: private final String dwellCommand; public M3Dweller(double dwellDuration) { this.dwellCommand = String.format(Locale.ROOT, \"G4P%.2f\", dwellDuration); } The help method simply adds some comments for the settings GUI: @Override public String getHelp() { return \"Add a delay after enabling the spindle with \\\"M3\\\" commands. \\\"M3\\\" must be the only command on the line.\"; } Everything is then pulled together in the processCommand method to return an extra dwell command when M3 is detected: // Contains an M3 not followed by another digit (i.e. M30) Pattern m3Pattern = Pattern.compile(\".*[mM]3(?!\\\\d)(\\\\D.*)?\"); @Override public List<String> processCommand(String command, GcodeState state) throws GcodeParserException { if (m3Pattern.matcher(command).matches()) { return Arrays.asList(command, dwellCommand); } return Collections.singletonList(command); } All at once now: public class M3Dweller implements CommandProcessor { private final String dwellCommand; // Contains an M3 not followed by another digit (i.e. M30) Pattern m3Pattern = Pattern.compile(\".*[mM]3(?!\\\\d)(\\\\D.*)?\"); public M3Dweller(double dwellDuration) { this.dwellCommand = String.format(Locale.ROOT, \"G4P%.2f\", dwellDuration); } @Override public List<String> processCommand(String command, GcodeState state) throws GcodeParserException { String noComments = GcodePreprocessorUtils.removeComment(command); if (m3Pattern.matcher(noComments).matches()) { return Arrays.asList(command, dwellCommand); } return Collections.singletonList(command); } @Override public String getHelp() { return \"Add a delay after enabling the spindle with \\\"M3\\\" commands. \\\"M3\\\" must be the only command on the line.\"; } }","title":"Creating the processor"},{"location":"dev/gcode_processor/#hooking-up-the-json","text":"The json files are stored in ugs-core/src/resources/firmware_config , each of these will be updated to include our new processor. Notice that we have an argument named duration, and that it is disabled by default: \"name\": \"M3Dweller\", \"enabled\": false, \"optional\": true, \"args\": { \"duration\": 2.5 } },{ We also increment the version string, which will prompt users that there is a new configuration file available and they may need to revisit their settings: - \"Version\": 3, + \"Version\": 4,","title":"Hooking up the JSON"},{"location":"dev/gcode_processor/#json-loader","text":"The last step is to update the CommandProcessorLoader to include logic that creates the new M3Dweller when needed. I used one of the other processors as an example and made sure to make a corresponding entry for the M3Dweller in each of the corresponding code and comment locations: case \"M3Dweller\": double duration = pc.args.get(\"duration\").getAsDouble(); p = new M3Dweller(duration); break; There is also a test which should be updated to make sure everything is working: + args = new JsonObject(); + args.addProperty(\"duration\", 2.5); + object = new JsonObject(); + object.addProperty(\"name\", \"M3Dweller\"); + object.add(\"args\", args); + array.add(object); + String jsonConfig = array.toString(); List<CommandProcessor> processors = CommandProcessorLoader.initializeWithProcessors(jsonConfig); - assertEquals(8, processors.size()); + assertEquals(9, processors.size()); assertEquals(ArcExpander.class, processors.get(0).getClass()); assertEquals(CommentProcessor.class, processors.get(1).getClass()); assertEquals(DecimalProcessor.class, processors.get(2).getClass()); assertEquals(FeedOverrideProcessor.class, processors.get(3).getClass()); assertEquals(M30Processor.class, processors.get(4).getClass()); assertEquals(PatternRemover.class, processors.get(5).getClass()); assertEquals(CommandLengthProcessor.class, processors.get(6).getClass()); assertEquals(WhitespaceProcessor.class, processors.get(7).getClass()); + assertEquals(M3Dweller.class, processors.get(8).getClass());","title":"JSON Loader"},{"location":"dev/gcode_processor/#testing","text":"The command processors lend themselves to thorough testing, so we create a new M3DwellerTest.java file in the associated test package and write some tests: @Test public void testReplaces() throws Exception { M3Dweller dweller = new M3Dweller(2.5); String command; command = \"M3\"; Assertions.assertThat(dweller.processCommand(command, null)).containsExactly(command,\"G4P2.50\"); command = \"m3\"; Assertions.assertThat(dweller.processCommand(command, null)).containsExactly(command,\"G4P2.50\"); command = \"M3 S1000\"; Assertions.assertThat(dweller.processCommand(command, null)).containsExactly(command,\"G4P2.50\"); command = \"m3 S1000\"; Assertions.assertThat(dweller.processCommand(command, null)).containsExactly(command,\"G4P2.50\"); command = \"(this is ignored) M3 S1000\"; Assertions.assertThat(dweller.processCommand(command, null)).containsExactly(command,\"G4P2.50\"); } @Test public void testNoOp() throws Exception { M3Dweller dweller = new M3Dweller(2.5); String command; command = \"anything else\"; Assertions.assertThat(dweller.processCommand(command, null)).containsExactly(command); command = \"M30\"; Assertions.assertThat(dweller.processCommand(command, null)).containsExactly(command); command = \"G0 X0 Y0 (definitely not ready to start the spindle with an M3 yet)\"; Assertions.assertThat(dweller.processCommand(command, null)).containsExactly(command); }","title":"Testing"},{"location":"dev/gcode_processor/#localizing","text":"In addition to the help message which may use the global Localization helper, the settings menu will attempt to find something with the same name as in the JSON file. So we add an entry to ./ugs-core/src/resources/MessagesBundle_en_US.properties , which will later be pulled into a separate localization service to be localized in other languages. WhitespaceProcessor = Whitespace Remover +M3Dweller = Spindle start delay controller.exception.smoothie.booting = Smoothie has not finished booting.","title":"Localizing"},{"location":"dev/gcode_processor/#conclusion","text":"We have now fully integrated our M3Dweller processor into the UGS framework and users of UGS and UGP can both make use of it. The raw commit for this feature is found on github here .","title":"Conclusion"},{"location":"dev/getting_started/","text":"Project Organization Universal Gcode Sender uses Maven to build the project. It is using maven modules to separate the core library / classic GUI and the UGS Platform project. At the top level a UGS target defines the ugs-core and ugs-platform-parent modules which can be built separately or all at once. The classic gui is part of the core project in the ugs-core module. The maven-shade-plugin and maven-assembly-plugin are generate the self-executing JAR and distribution zip. UGS Platform is built on the NetBeans Platform . It is also using maven. Development is done using NetBeans, but most of the code can be edited using any IDE that supports Maven. Development with an IDE Any IDE supporting Maven should be able to open the UGS project directory. Once opened it should show you the ugs-core and ugs-platform-parent modules which correspond to the Classic and Platform interfaces. Development is done using NetBeans, and for some project development NetBeans is almost required. But for tweaking the UI and experimenting with the backend any IDE which supports maven can be used. Classic GUI In the ugs-core module, you can run the MainWindow.java file to start the Classic GUI. UGS Platform The platform build has a number of submodules. Load the suite of modules by running the ugs-platform-app module. Development with the Command Line The UGS Classic and Platform interfaces can also be run from the command line. These commands should be run from the root directory. Classic GUI There is a helper script named run_classic.sh , or you can use the commands below. Running the UI mvn install mvn exec:java -Dexec.mainClass=\"com.willwinder.universalgcodesender.MainWindow\" -pl ugs-core Executing tests mvn install mvn test -pl ugs-core Building the self-executing JAR mvn install mvn package -pl ugs-core Building a UniversalGcodeSender.zip release file mvn package assembly:assembly UGS Platform There is a helper script named run_platform.sh , or you can use the commands below. Running the UI mvn install mvn nbm:run-platform -pl ugs-platform/application","title":"Project Organization"},{"location":"dev/getting_started/#project-organization","text":"Universal Gcode Sender uses Maven to build the project. It is using maven modules to separate the core library / classic GUI and the UGS Platform project. At the top level a UGS target defines the ugs-core and ugs-platform-parent modules which can be built separately or all at once. The classic gui is part of the core project in the ugs-core module. The maven-shade-plugin and maven-assembly-plugin are generate the self-executing JAR and distribution zip. UGS Platform is built on the NetBeans Platform . It is also using maven. Development is done using NetBeans, but most of the code can be edited using any IDE that supports Maven.","title":"Project Organization"},{"location":"dev/getting_started/#development-with-an-ide","text":"Any IDE supporting Maven should be able to open the UGS project directory. Once opened it should show you the ugs-core and ugs-platform-parent modules which correspond to the Classic and Platform interfaces. Development is done using NetBeans, and for some project development NetBeans is almost required. But for tweaking the UI and experimenting with the backend any IDE which supports maven can be used.","title":"Development with an IDE"},{"location":"dev/getting_started/#classic-gui","text":"In the ugs-core module, you can run the MainWindow.java file to start the Classic GUI.","title":"Classic GUI"},{"location":"dev/getting_started/#ugs-platform","text":"The platform build has a number of submodules. Load the suite of modules by running the ugs-platform-app module.","title":"UGS Platform"},{"location":"dev/getting_started/#development-with-the-command-line","text":"The UGS Classic and Platform interfaces can also be run from the command line. These commands should be run from the root directory.","title":"Development with the Command Line"},{"location":"dev/getting_started/#classic-gui_1","text":"There is a helper script named run_classic.sh , or you can use the commands below.","title":"Classic GUI"},{"location":"dev/getting_started/#running-the-ui","text":"mvn install mvn exec:java -Dexec.mainClass=\"com.willwinder.universalgcodesender.MainWindow\" -pl ugs-core","title":"Running the UI"},{"location":"dev/getting_started/#executing-tests","text":"mvn install mvn test -pl ugs-core","title":"Executing tests"},{"location":"dev/getting_started/#building-the-self-executing-jar","text":"mvn install mvn package -pl ugs-core","title":"Building the self-executing JAR"},{"location":"dev/getting_started/#building-a-universalgcodesenderzip-release-file","text":"mvn package assembly:assembly","title":"Building a UniversalGcodeSender.zip release file"},{"location":"dev/getting_started/#ugs-platform_1","text":"There is a helper script named run_platform.sh , or you can use the commands below.","title":"UGS Platform"},{"location":"dev/getting_started/#running-the-ui_1","text":"mvn install mvn nbm:run-platform -pl ugs-platform/application","title":"Running the UI"},{"location":"dev/plugin/","text":"Note: The UGS Platform has been updated to use maven. Some parts of this document need to be updated to reflect that change. Plugin development The UGS Platform is built ontop of the NetBeans Platform. This gives us powerful tools to work with, including a robust plugin system. The heart of the UGS Platform is a module which wraps and exposes the Universal Gcode Sender JAR file - the same jar you could execute to run the Classic GUI! Other than using the UGSLib module, developing a plugin for the UGS Platform is exactly the same as developing any other NetBeans Platform plugin. And there is lots of great documentation for that, here is the NetBeans Platform Plugin Quick Start guide. Workflow Plugin Tutorial In this tutorial we're going to build a window to help manage jobs that use multiple tools which are split into multiple files. The rough design idea will have a central table with four columns containing: * File name * Tool name (editable) * Finished flag There will be a pair of buttons to add and remove files from the table, and we will also hook up a UGS event listener to detect when files are opened from other areas of the interface as well. Lastly, we'll add another pair of buttons to move rows around in the table, so that we can reorganize the workflow if files were added out of order the order. Here is a sketch of what we're building: Create and configure project Universal Gcode Sender is developed with NetBeans, and plugins are no exception. Once you've cloned the Universal Gcode Sender project you should be able to open the UGSPlatform folder with NetBeans and it will discover a project that you can open. To start building your module expand the UGSPlatform section, right-click the modules directory and select Add New... . This will open up a wizard where you name the module, and declare the source path. For this example the module is named WorkflowModuleTutorial and the source path is com.willwinder.ugs.nbp.workflowmoduletutorial which is the convention used in the core modules. Add UGS dependencies Your module should now be listed in the Modules section. If it doesn't you may need to restart NetBeans. Before we dive into the code there are a couple helper classes to import which will give you full access to the UGS API. Double click your module from the Modules section to open the code, then right-click the top level item which appeared and select the properties menu. Select Add Dependency... , here you should search for UGSLib and CentralLookup then add them to your plugin. Create window class Now we're ready to build the module. In this tutorial we're building a window to manage a multi-job workflow, so we'll start by adding a window to customize. Open the new module and right click the new package, in the context menu go to New -> Window... . To bring up the new window wizard. In the first screen of the wizard choose the default location your window will appear. Custom locations have been designed for UGS Platform, the largest is named visualizer because it is the Visualizer's default location. We'll use this location for our plugin. This means that when our plugin opens it will be tabbed with the Visualizer module. Click next and choose a class name for your module, for this tutorial I'm going to call it WorkflowModuleTutorial . Build the GUI The NetBeans GUI builder makes it easy to make a custom user interface without writing a single line of code (which is the main reason UGS uses NetBeans!). Using the GUI builder we'll add some buttons and a table. This step can be as elaborate as you want. If you're a seasoned swing developer and prefer not to use the magic GUI builder, no worries, you can create the UI programatically as well - but that is a different tutorial. Take a look at the screenshot below. The [TopComponent] - Navigator - Editor window shows all the objects that have been added with the GUI builder. There are four JButtons, a JTable nested inside a JScrollPane and a JPanel which I used to make alignment a little easier (The GUI Builder is powerful, but it can also be a bit quirky). Putting the JTable inside a JScrollPane makes it so that if too many items get added to the table it will scroll rather than dissapear off the bottom. Note: The name given to these components will be used in the code, so be sure to use the names shown in the screenshot. The JTable is going to be the trickiest part of build the GUI. To configure the table right-click the JTable object from the component navigator and select Table Contents... . Here you can add our 3 columns and specify that the data types. You can also specify which columns are editable, in this example we want the user to be able to type in what type of tool should be used. Autogenerated code Before writing any code, lets take a look at what has already been automatically generated for us. Just above the class there are a number of annotations. These are used by the NetBeans platform, most of them were setup according to how you filled in the Wizards earlier. They can also configure things like keyboard shortcuts, and where things are put in the dropdown menus. Within the class there are several grayed out sections. This is code generated by NetBeans which the IDE prevents you from modifying outside the GUI builder or in some cases component properties. For example if you wanted to use a custom JTable, you would configure the table in the GUI builder by adding a custom constructor. At the end of the file is componentOpened and componentClosed , these are lifecycle events that are called when the window has been opened or closed. Also at the end of the file is writeProperties and readProperties , these are used to save the window state between runs. Annotated code This is the longest section because it will explain every line of code added to the WorkflowModuleTutorial class. The most complicated code deals with Swing component manipulation, with just a smattering of UGS lifecycle events to push things along. Class signature First there are a few class state object we'll need and two Listeners we'll be implementing. /** * UGSEventListener - this is how a plugin can listen to UGS lifecycle events. * ListSelectionListener - listen for table selections. */ public final class WorkflowWindowTutorialTopComponent extends TopComponent implements UGSEventListener, ListSelectionListener { // These are the UGS backend objects for interacting with the backend. private final Settings settings; private final BackendAPI backend; // This is used to identify when a stream has completed. private boolean wasSending; // This is used in most methods, so cache it here. DefaultTableModel model; Constructor In the constructor we register the class with the UGS backend and also set the class as a listener to table selection events. public WorkflowWindowTopComponent() { initComponents(); setName(Bundle.CTL_WorkflowWindowTopComponent()); setToolTipText(Bundle.HINT_WorkflowWindowTopComponent()); // This is how to access the UGS backend and register the listener. // CentralLookup is used to get singleton instances of the UGS // Settings and BackendAPI objects. settings = CentralLookup.getDefault().lookup(Settings.class); backend = CentralLookup.getDefault().lookup(BackendAPI.class); backend.addUGSEventListener(this); // Allow contiguous ranges of selections and register a listener. this.fileTable.setSelectionMode( ListSelectionModel.SINGLE_INTERVAL_SELECTION); ListSelectionModel cellSelectionModel = this.fileTable.getSelectionModel(); cellSelectionModel.addListSelectionListener(this); // Cache the model object. model = (DefaultTableModel)this.fileTable.getModel(); } UGS Event Listener This is the event sent from the UGS Backend, when a file is loaded or the state changes a notification will be sent. If the state switches from COMM_SENDING to COMM_IDLE we'll run a completeFile method. If a file is loaded, we add it to the table. @Override public void UGSEvent(UGSEvent cse) { if (cse.isStateChangeEvent()) { if (wasSending && cse.getControlState() == ControlState.COMM_IDLE) this.completeFile(backend.getGcodeFile()); wasSending = backend.isSending(); } if (cse.isFileChangeEvent()) { this.addFileToWorkflow(backend.getGcodeFile()); } } File Complete Handler When a command is complete we'll update the JTable, select the next file that needs to be sent and popup a notification informing the user what they should do next. The selection event will be sent and handled in the selection handler. public void completeFile(File gcodeFile) { if (gcodeFile == null) return; // Make sure the file is loaded in the table. int fileIndex = findFileIndex(gcodeFile); if (fileIndex < 0) return; // Mark that it has been completed. model.setValueAt(true, fileIndex, 2); fileIndex++; String message; // Make sure there is another command left. if (fileIndex < fileTable.getRowCount()) { String nextTool = (String) model.getValueAt(fileIndex, 1); String messageTemplate = \"Finished sending '%s'.\\n\" + \"The next file uses tool '%s'\\n\" + \"Load tool and move machine to its zero location\\n\" + \"and click send to continue this workflow.\"; message = String.format( messageTemplate, gcodeFile.getName(), nextTool); // Select the next row, this will trigger a selection event. fileTable.setRowSelectionInterval(fileIndex, fileIndex); // Use a different message if we're finished. } else { message = \"Finished sending the last file!\"; } // Display a notification. java.awt.EventQueue.invokeLater(() -> { JOptionPane.showMessageDialog(new JFrame(), message, \"Workflow Event\", JOptionPane.PLAIN_MESSAGE); }); } JTable Selection Listener This is the selection listener, when a file is selected load it in the backend. @Override public void valueChanged(ListSelectionEvent e) { int[] selectedRow = fileTable.getSelectedRows(); // Only load files when there is a single selection. if (selectedRow.length == 1) { // Pull the file out of the table and set it in the backend. String file = (String) model.getValueAt(selectedRow[0], 0); try { backend.setGcodeFile(new File(file)); } catch (Exception ex) { Exceptions.printStackTrace(ex); } } } JTable Helper Helper method to add a file to the JTable, first making sure that it isn't already in the table. public void addFileToWorkflow(File gcodeFile) { if (gcodeFile == null) { return; } int fileIndex = findFileIndex(gcodeFile); // Don't re-add a file. if (fileIndex >= 0) { return; } model.addRow(new Object[]{ gcodeFile.getAbsolutePath(), \"default\", false }); // Fire off the selection event to load the file. int lastRow = fileTable.getRowCount() - 1; fileTable.setRowSelectionInterval(lastRow, lastRow); } Add/Remove Button Action Handlers Now we implement the button event methods. They are generated by double clicking the buttons in the GUI Builder. This generates the swing code that attaches the ActionPerformed events to the button click callbacks. addButtonActionPerformed simply displays a file chooser (using some UGS library built ins) and calls the addFileToWorkflow method defined earlier. removeButtonActoinPerformed is even simpler, it uses standard JTable functionality to remove any selected rows. The only thing clever here is that rows are removed starting from the end to avoid having the index of later selections change while deleting rows one at a time. private void addButtonActionPerformed(ActionEvent evt) { // Open a file chooser pointing at the last opened directory. JFileChooser fileChooser = GcodeFileTypeFilter.getGcodeFileChooser( settings.getLastOpenedFilename()); int returnVal = fileChooser.showOpenDialog(this); if (returnVal == JFileChooser.APPROVE_OPTION) { File gcodeFile = fileChooser.getSelectedFile(); // Save the new directory! settings.setLastOpenedFilename(gcodeFile.getParent()); addFileToWorkflow(gcodeFile); } } private void removeButtonActionPerformed(ActionEvent evt) { int[] selectedRows = fileTable.getSelectedRows(); if (selectedRows.length == 0) return; Arrays.sort(selectedRows); for (int i = selectedRows.length - 1; i >= 0; i--) { int row = selectedRows[i] this.model.removeRow(row); this.model.fireTableRowsDeleted(row, row); } } Up / Down Button Action Handlers The up and down action buttons are pure java code. They don't do anything you wouldn't do with any other Swing application. The code here deals strictly with moving selections around. Although a little tricky, and not totally relevant to UGS, they are included because the feature wouldn't be complete without them. private void upButtonActionPerformed(ActionEvent evt) { int[] selectedRows = fileTable.getSelectedRows(); // Exit early if nothing is selected. if (selectedRows.length == 0) return; Arrays.sort(selectedRows); // Exit early if the selected range can't move. if (selectedRows[0] == 0) return; for (int i = 0; i < selectedRows.length; i++) { selectedRows[i] = this.moveRow(selectedRows[i], -1); } int first = selectedRows[0]; int last = selectedRows[selectedRows.length-1]; fileTable.setRowSelectionInterval(first, last); } private void downButtonActionPerformed(ActionEvent evt) { int[] selectedRows = fileTable.getSelectedRows(); // Exit early if nothing is selected. if (selectedRows.length == 0) return; Arrays.sort(selectedRows); // Exit early if the selected range can't move. if (selectedRows[selectedRows.length-1] == fileTable.getRowCount()) return; for (int i = selectedRows.length - 1; i >= 0; i--) { selectedRows[i] = this.moveRow(selectedRows[i], 1); } int first = selectedRows[0]; int last = selectedRows[selectedRows.length-1]; fileTable.setRowSelectionInterval(first, last); } NetBeans Platform Component Lifecycle Code Of the automatically generated methods, componentOpened is the only one which needed some custom code. In case the component had been closed earlier or wasn't loaded until after a file stream started, grab the wasSending state and save it for later. @Override public void componentOpened() { this.wasSending = backend.isSending(); } @Override public void componentClosed() { // No special close handling. } void writeProperties(java.util.Properties p) { // better to version settings since initial version as advocated at // http://wiki.apidesign.org/wiki/PropertyFiles p.setProperty(\"version\", \"1.0\"); // We could save the loaded files here } void readProperties(java.util.Properties p) { String version = p.getProperty(\"version\"); // We could load previously loaded files here } Helper Methods Finally, here are the helper methods used above. /** * Look for the provided file in the file table. */ private int findFileIndex(File gcodeFile) { if (gcodeFile == null) return -1; for (int i = 0; i < model.getRowCount(); i++) { String file = (String) model.getValueAt(i, 0); if (file != null && gcodeFile.getAbsolutePath().equals(file)) { return i; } } return -1; } /** * Move a given row by some offset. If the offset would move the row outside * of the current table size, the row is not moved. */ private int moveRow(int row, int offset) { int dest = row + offset; if (dest < 0 || dest >= model.getRowCount()) { return row; } model.moveRow(row, row, dest); return dest; } Conclusion Here is a quick screencast of what this plugin does for us. In the GUI builder I swapped in some up/down arrows compared to the tutorial.","title":"Note: The UGS Platform has been updated to use maven. Some parts of this document need to be updated to reflect that change."},{"location":"dev/plugin/#note-the-ugs-platform-has-been-updated-to-use-maven-some-parts-of-this-document-need-to-be-updated-to-reflect-that-change","text":"","title":"Note: The UGS Platform has been updated to use maven. Some parts of this document need to be updated to reflect that change."},{"location":"dev/plugin/#plugin-development","text":"The UGS Platform is built ontop of the NetBeans Platform. This gives us powerful tools to work with, including a robust plugin system. The heart of the UGS Platform is a module which wraps and exposes the Universal Gcode Sender JAR file - the same jar you could execute to run the Classic GUI! Other than using the UGSLib module, developing a plugin for the UGS Platform is exactly the same as developing any other NetBeans Platform plugin. And there is lots of great documentation for that, here is the NetBeans Platform Plugin Quick Start guide.","title":"Plugin development"},{"location":"dev/plugin/#workflow-plugin-tutorial","text":"In this tutorial we're going to build a window to help manage jobs that use multiple tools which are split into multiple files. The rough design idea will have a central table with four columns containing: * File name * Tool name (editable) * Finished flag There will be a pair of buttons to add and remove files from the table, and we will also hook up a UGS event listener to detect when files are opened from other areas of the interface as well. Lastly, we'll add another pair of buttons to move rows around in the table, so that we can reorganize the workflow if files were added out of order the order. Here is a sketch of what we're building:","title":"Workflow Plugin Tutorial"},{"location":"dev/plugin/#create-and-configure-project","text":"Universal Gcode Sender is developed with NetBeans, and plugins are no exception. Once you've cloned the Universal Gcode Sender project you should be able to open the UGSPlatform folder with NetBeans and it will discover a project that you can open. To start building your module expand the UGSPlatform section, right-click the modules directory and select Add New... . This will open up a wizard where you name the module, and declare the source path. For this example the module is named WorkflowModuleTutorial and the source path is com.willwinder.ugs.nbp.workflowmoduletutorial which is the convention used in the core modules.","title":"Create and configure project"},{"location":"dev/plugin/#add-ugs-dependencies","text":"Your module should now be listed in the Modules section. If it doesn't you may need to restart NetBeans. Before we dive into the code there are a couple helper classes to import which will give you full access to the UGS API. Double click your module from the Modules section to open the code, then right-click the top level item which appeared and select the properties menu. Select Add Dependency... , here you should search for UGSLib and CentralLookup then add them to your plugin.","title":"Add UGS dependencies"},{"location":"dev/plugin/#create-window-class","text":"Now we're ready to build the module. In this tutorial we're building a window to manage a multi-job workflow, so we'll start by adding a window to customize. Open the new module and right click the new package, in the context menu go to New -> Window... . To bring up the new window wizard. In the first screen of the wizard choose the default location your window will appear. Custom locations have been designed for UGS Platform, the largest is named visualizer because it is the Visualizer's default location. We'll use this location for our plugin. This means that when our plugin opens it will be tabbed with the Visualizer module. Click next and choose a class name for your module, for this tutorial I'm going to call it WorkflowModuleTutorial .","title":"Create window class"},{"location":"dev/plugin/#build-the-gui","text":"The NetBeans GUI builder makes it easy to make a custom user interface without writing a single line of code (which is the main reason UGS uses NetBeans!). Using the GUI builder we'll add some buttons and a table. This step can be as elaborate as you want. If you're a seasoned swing developer and prefer not to use the magic GUI builder, no worries, you can create the UI programatically as well - but that is a different tutorial. Take a look at the screenshot below. The [TopComponent] - Navigator - Editor window shows all the objects that have been added with the GUI builder. There are four JButtons, a JTable nested inside a JScrollPane and a JPanel which I used to make alignment a little easier (The GUI Builder is powerful, but it can also be a bit quirky). Putting the JTable inside a JScrollPane makes it so that if too many items get added to the table it will scroll rather than dissapear off the bottom. Note: The name given to these components will be used in the code, so be sure to use the names shown in the screenshot. The JTable is going to be the trickiest part of build the GUI. To configure the table right-click the JTable object from the component navigator and select Table Contents... . Here you can add our 3 columns and specify that the data types. You can also specify which columns are editable, in this example we want the user to be able to type in what type of tool should be used.","title":"Build the GUI"},{"location":"dev/plugin/#autogenerated-code","text":"Before writing any code, lets take a look at what has already been automatically generated for us. Just above the class there are a number of annotations. These are used by the NetBeans platform, most of them were setup according to how you filled in the Wizards earlier. They can also configure things like keyboard shortcuts, and where things are put in the dropdown menus. Within the class there are several grayed out sections. This is code generated by NetBeans which the IDE prevents you from modifying outside the GUI builder or in some cases component properties. For example if you wanted to use a custom JTable, you would configure the table in the GUI builder by adding a custom constructor. At the end of the file is componentOpened and componentClosed , these are lifecycle events that are called when the window has been opened or closed. Also at the end of the file is writeProperties and readProperties , these are used to save the window state between runs.","title":"Autogenerated code"},{"location":"dev/plugin/#annotated-code","text":"This is the longest section because it will explain every line of code added to the WorkflowModuleTutorial class. The most complicated code deals with Swing component manipulation, with just a smattering of UGS lifecycle events to push things along.","title":"Annotated code"},{"location":"dev/plugin/#class-signature","text":"First there are a few class state object we'll need and two Listeners we'll be implementing. /** * UGSEventListener - this is how a plugin can listen to UGS lifecycle events. * ListSelectionListener - listen for table selections. */ public final class WorkflowWindowTutorialTopComponent extends TopComponent implements UGSEventListener, ListSelectionListener { // These are the UGS backend objects for interacting with the backend. private final Settings settings; private final BackendAPI backend; // This is used to identify when a stream has completed. private boolean wasSending; // This is used in most methods, so cache it here. DefaultTableModel model;","title":"Class signature"},{"location":"dev/plugin/#constructor","text":"In the constructor we register the class with the UGS backend and also set the class as a listener to table selection events. public WorkflowWindowTopComponent() { initComponents(); setName(Bundle.CTL_WorkflowWindowTopComponent()); setToolTipText(Bundle.HINT_WorkflowWindowTopComponent()); // This is how to access the UGS backend and register the listener. // CentralLookup is used to get singleton instances of the UGS // Settings and BackendAPI objects. settings = CentralLookup.getDefault().lookup(Settings.class); backend = CentralLookup.getDefault().lookup(BackendAPI.class); backend.addUGSEventListener(this); // Allow contiguous ranges of selections and register a listener. this.fileTable.setSelectionMode( ListSelectionModel.SINGLE_INTERVAL_SELECTION); ListSelectionModel cellSelectionModel = this.fileTable.getSelectionModel(); cellSelectionModel.addListSelectionListener(this); // Cache the model object. model = (DefaultTableModel)this.fileTable.getModel(); }","title":"Constructor"},{"location":"dev/plugin/#ugs-event-listener","text":"This is the event sent from the UGS Backend, when a file is loaded or the state changes a notification will be sent. If the state switches from COMM_SENDING to COMM_IDLE we'll run a completeFile method. If a file is loaded, we add it to the table. @Override public void UGSEvent(UGSEvent cse) { if (cse.isStateChangeEvent()) { if (wasSending && cse.getControlState() == ControlState.COMM_IDLE) this.completeFile(backend.getGcodeFile()); wasSending = backend.isSending(); } if (cse.isFileChangeEvent()) { this.addFileToWorkflow(backend.getGcodeFile()); } }","title":"UGS Event Listener"},{"location":"dev/plugin/#file-complete-handler","text":"When a command is complete we'll update the JTable, select the next file that needs to be sent and popup a notification informing the user what they should do next. The selection event will be sent and handled in the selection handler. public void completeFile(File gcodeFile) { if (gcodeFile == null) return; // Make sure the file is loaded in the table. int fileIndex = findFileIndex(gcodeFile); if (fileIndex < 0) return; // Mark that it has been completed. model.setValueAt(true, fileIndex, 2); fileIndex++; String message; // Make sure there is another command left. if (fileIndex < fileTable.getRowCount()) { String nextTool = (String) model.getValueAt(fileIndex, 1); String messageTemplate = \"Finished sending '%s'.\\n\" + \"The next file uses tool '%s'\\n\" + \"Load tool and move machine to its zero location\\n\" + \"and click send to continue this workflow.\"; message = String.format( messageTemplate, gcodeFile.getName(), nextTool); // Select the next row, this will trigger a selection event. fileTable.setRowSelectionInterval(fileIndex, fileIndex); // Use a different message if we're finished. } else { message = \"Finished sending the last file!\"; } // Display a notification. java.awt.EventQueue.invokeLater(() -> { JOptionPane.showMessageDialog(new JFrame(), message, \"Workflow Event\", JOptionPane.PLAIN_MESSAGE); }); }","title":"File Complete Handler"},{"location":"dev/plugin/#jtable-selection-listener","text":"This is the selection listener, when a file is selected load it in the backend. @Override public void valueChanged(ListSelectionEvent e) { int[] selectedRow = fileTable.getSelectedRows(); // Only load files when there is a single selection. if (selectedRow.length == 1) { // Pull the file out of the table and set it in the backend. String file = (String) model.getValueAt(selectedRow[0], 0); try { backend.setGcodeFile(new File(file)); } catch (Exception ex) { Exceptions.printStackTrace(ex); } } }","title":"JTable Selection Listener"},{"location":"dev/plugin/#jtable-helper","text":"Helper method to add a file to the JTable, first making sure that it isn't already in the table. public void addFileToWorkflow(File gcodeFile) { if (gcodeFile == null) { return; } int fileIndex = findFileIndex(gcodeFile); // Don't re-add a file. if (fileIndex >= 0) { return; } model.addRow(new Object[]{ gcodeFile.getAbsolutePath(), \"default\", false }); // Fire off the selection event to load the file. int lastRow = fileTable.getRowCount() - 1; fileTable.setRowSelectionInterval(lastRow, lastRow); }","title":"JTable Helper"},{"location":"dev/plugin/#addremove-button-action-handlers","text":"Now we implement the button event methods. They are generated by double clicking the buttons in the GUI Builder. This generates the swing code that attaches the ActionPerformed events to the button click callbacks. addButtonActionPerformed simply displays a file chooser (using some UGS library built ins) and calls the addFileToWorkflow method defined earlier. removeButtonActoinPerformed is even simpler, it uses standard JTable functionality to remove any selected rows. The only thing clever here is that rows are removed starting from the end to avoid having the index of later selections change while deleting rows one at a time. private void addButtonActionPerformed(ActionEvent evt) { // Open a file chooser pointing at the last opened directory. JFileChooser fileChooser = GcodeFileTypeFilter.getGcodeFileChooser( settings.getLastOpenedFilename()); int returnVal = fileChooser.showOpenDialog(this); if (returnVal == JFileChooser.APPROVE_OPTION) { File gcodeFile = fileChooser.getSelectedFile(); // Save the new directory! settings.setLastOpenedFilename(gcodeFile.getParent()); addFileToWorkflow(gcodeFile); } } private void removeButtonActionPerformed(ActionEvent evt) { int[] selectedRows = fileTable.getSelectedRows(); if (selectedRows.length == 0) return; Arrays.sort(selectedRows); for (int i = selectedRows.length - 1; i >= 0; i--) { int row = selectedRows[i] this.model.removeRow(row); this.model.fireTableRowsDeleted(row, row); } }","title":"Add/Remove Button Action Handlers"},{"location":"dev/plugin/#up-down-button-action-handlers","text":"The up and down action buttons are pure java code. They don't do anything you wouldn't do with any other Swing application. The code here deals strictly with moving selections around. Although a little tricky, and not totally relevant to UGS, they are included because the feature wouldn't be complete without them. private void upButtonActionPerformed(ActionEvent evt) { int[] selectedRows = fileTable.getSelectedRows(); // Exit early if nothing is selected. if (selectedRows.length == 0) return; Arrays.sort(selectedRows); // Exit early if the selected range can't move. if (selectedRows[0] == 0) return; for (int i = 0; i < selectedRows.length; i++) { selectedRows[i] = this.moveRow(selectedRows[i], -1); } int first = selectedRows[0]; int last = selectedRows[selectedRows.length-1]; fileTable.setRowSelectionInterval(first, last); } private void downButtonActionPerformed(ActionEvent evt) { int[] selectedRows = fileTable.getSelectedRows(); // Exit early if nothing is selected. if (selectedRows.length == 0) return; Arrays.sort(selectedRows); // Exit early if the selected range can't move. if (selectedRows[selectedRows.length-1] == fileTable.getRowCount()) return; for (int i = selectedRows.length - 1; i >= 0; i--) { selectedRows[i] = this.moveRow(selectedRows[i], 1); } int first = selectedRows[0]; int last = selectedRows[selectedRows.length-1]; fileTable.setRowSelectionInterval(first, last); }","title":"Up / Down Button Action Handlers"},{"location":"dev/plugin/#netbeans-platform-component-lifecycle-code","text":"Of the automatically generated methods, componentOpened is the only one which needed some custom code. In case the component had been closed earlier or wasn't loaded until after a file stream started, grab the wasSending state and save it for later. @Override public void componentOpened() { this.wasSending = backend.isSending(); } @Override public void componentClosed() { // No special close handling. } void writeProperties(java.util.Properties p) { // better to version settings since initial version as advocated at // http://wiki.apidesign.org/wiki/PropertyFiles p.setProperty(\"version\", \"1.0\"); // We could save the loaded files here } void readProperties(java.util.Properties p) { String version = p.getProperty(\"version\"); // We could load previously loaded files here }","title":"NetBeans Platform Component Lifecycle Code"},{"location":"dev/plugin/#helper-methods","text":"Finally, here are the helper methods used above. /** * Look for the provided file in the file table. */ private int findFileIndex(File gcodeFile) { if (gcodeFile == null) return -1; for (int i = 0; i < model.getRowCount(); i++) { String file = (String) model.getValueAt(i, 0); if (file != null && gcodeFile.getAbsolutePath().equals(file)) { return i; } } return -1; } /** * Move a given row by some offset. If the offset would move the row outside * of the current table size, the row is not moved. */ private int moveRow(int row, int offset) { int dest = row + offset; if (dest < 0 || dest >= model.getRowCount()) { return row; } model.moveRow(row, row, dest); return dest; }","title":"Helper Methods"},{"location":"dev/plugin/#conclusion","text":"Here is a quick screencast of what this plugin does for us. In the GUI builder I swapped in some up/down arrows compared to the tutorial.","title":"Conclusion"}]}